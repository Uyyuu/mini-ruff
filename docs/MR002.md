実装依頼内容

mini-ruff に print() 呼び出し検出ルールを実装してください。

目的

ソースコード中の print() 関数呼び出しを検出し、Lint エラーとして報告する。

本番コードにデバッグ用の print() が残ることを防止する。

本ルールは tree-sitter AST を活用した検出の実装例として、正確な構文解析に基づく検出を行う。

ルール仕様
ルールID
MR002

検出対象

以下のパターンを検出する：

print("hello")

print(x, y)

print()

※ トップレベル関数としての print 呼び出しが対象

非対象

文字列内の print（例："print('hello')"）

コメント内の print（例：# print(x)）

別オブジェクトのメソッド呼び出し（例：logger.print()）

変数名としての print（例：print = 42）

エラー出力仕様
フォーマット
<file>:<line>:<column> MR002 print() usage is not allowed

例
example.py:22:1 MR002 print() usage is not allowed

実装方針
v0.1 では tree-sitter AST ベースで検出する

以下の方針で実装：

tree-sitter AST から call expression ノードを探索

関数名が print であるノードを検出

メソッド呼び出し（attribute access）は除外する

可読性優先

過剰な抽象化は禁止

実装要件

1. Rule Trait 実装

以下の Rule trait に従う：

pub trait Rule {
fn id(&self) -> &'static str;
fn check(&self, ctx: &LintContext) -> Vec<Diagnostic>;
}

2. PrintCallRule 実装

新規作成：

src/lint/rules/print_call.rs

3. 実装内容

以下を実装する：

tree-sitter AST を走査し call ノードを取得

call ノードの function 部分が identifier で、名前が "print" であることを確認

attribute（例：obj.print()）経由の呼び出しは除外

該当ノードの位置情報から Diagnostic を生成

4. Diagnostic 情報

必須：

rule_id = "MR002"

message = "print() usage is not allowed"

line = 検出行

column = print の開始位置

5. Rule Engine 登録

PrintCallRule を Rule Engine に登録する。

LintContext 利用

以下を利用：

ctx.source

ctx.tree（tree-sitter AST）

テスト要件

以下のケースを追加：

正常ケース（検出なし）
x = 1 + 2

→ Diagnostic なし

検出ケース

print("hello")

→ Diagnostic あり

引数なし

print()

→ Diagnostic あり

複数引数

print(x, y, z)

→ Diagnostic あり

メソッド呼び出し（非検出）

logger.print("msg")

→ Diagnostic なし

コメント内（非検出）

# print("debug")

→ Diagnostic なし

複数検出

print("a")
print("b")

→ 2件検出

非機能要件

パニック禁止

unwrap 最小限

anyhow / Result でエラー管理

実装スタイル

可読性優先

コメント適度に追加

複雑な抽象化禁止

trait object 使用はOK

将来拡張（実装不要）

pprint 検出対応

特定関数のホワイトリスト / ブラックリスト

autofix（print 行の削除・logging への置換提案）

実装は学習目的のため、最小限かつ読みやすいコードを優先してください。
パフォーマンス最適化は不要です。
